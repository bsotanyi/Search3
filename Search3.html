<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search3</title>
    <link rel="stylesheet" href="css/main.min.css">
</head>
<body>
    <h1>Search<mark>3</mark></h1>
    <fieldset class="grid-md-2">
        <legend>Options</legend>
        <form id="input">
            <div class="grid-sm-2" style="margin-bottom: 1rem;">
                <div class="form-group">
                    <div>
                        <label>Problem:</label>
                        <select name="problem" id="problem"></select>
                    </div>
                </div>
                <div class="form-group">
                    <label>Graph format:</label>
                    <label>
                        <input type="radio" name="format" value="compact"></input>
                        compact (small, faster)
                    </label>
                    <label><input type="radio" name="format" value="pretty" checked></input>
                        pretty (large, slower)
                    </label>
                </div>
                <div class="grid-2">
                    <div class="form-group">
                        <label>Graph direction:</label>
                        <label>
                            <input type="radio" name="direction" value="down" checked></input>
                            down ↓
                        </label>
                        <label><input type="radio" name="direction" value="right"></input>
                            right →
                        </label>
                    </div>
                    <div class="form-group">
                        <label>Output type:</label>
                        <label>
                            <input type="radio" name="output" value="png" checked></input>
                            canvas (PNG)
                        </label>
                        <label><input type="radio" name="output" value="svg"></input>
                            SVG
                        </label>
                    </div>
                </div>
                <div class="form-group">
                    <label>I want to see:</label>
                    <label>
                        <input type="radio" name="mode" value="all" checked></input>
                        all possible paths
                    </label>
                    <label><input type="radio" name="mode" value="shortest"></input>
                        only the shortest possible path
                    </label>
                </div>
            </div>
        </form>
        <div id="input_area"></div>
        <div style="grid-column: span 2;">
            <input type="submit" value="Generate" id="generate_btn">
            <span id="generate_info"></span>
            <span class="copyright">&copy; 2023 S.B.</span>
        </div>
    </fieldset>

    <canvas id="canvas_output"></canvas>
    <div id="svg_output"></div>
    <script src="graphre.js"></script>
    <script src="nomnoml.js"></script>
    <script>
        let problems = [];
    </script>
    <script src="problems/wolf-goat-cabbage.js"></script>
    <script src="problems/cannibals-priests.js"></script>
    <script src="problems/jumping-frogs.js"></script>
    <script>
        function qs(selector, parent_el = document) { return parent_el.querySelector(selector); }
        function qsa(selector, parent_el = document) { return [...parent_el.querySelectorAll(selector)]; }
        function serializeForm(form) {
            var obj = {};
            var formData = new FormData(form);
            for (var key of formData.keys()) {
                obj[key] = formData.get(key);
            }
            return obj;
        };

        let start_time = null;

        let input_html = '';
        for (let i in problems) {
            let new_opt = new Option(problems[i].title, i);
            qs('#problem').add(new_opt, undefined);

            if (problems[i].input_vars) {
                let inputs = ``;
                for (key in problems[i].input_vars) {
                    inputs += `
                        <label>${key}</label>
                        <div class="js-num">
                            <button type="button" class="js-minus">-</button>
                            <input name="${key}" type="number" value="${problems[i].input_vars[key]}">
                            <button type="button" class="js-plus">+</button>
                        </div>
                    `;
                }
                input_html += `<form style="display:none" data-input-vars data-problem-id="${i}">
                    <fieldset class="grid-2">
                        <legend>Input variables</legend>
                        ${inputs}
                    </fieldset>
                </form>`;
            }
        }
        qs('#input_area').innerHTML = input_html;
        for (let num of qsa('.js-num')) {
            qs('.js-plus', num).onclick = () => qs('input', num).value = ~~qs('input', num).value + 1;
            qs('.js-minus', num).onclick = () => qs('input', num).value = ~~qs('input', num).value - 1;
        }
        
        qs('#problem').addEventListener('input', function() {
            refreshInputArea(this.value);
        });
        refreshInputArea(qs('#problem').value);

        function refreshInputArea(problem_id) {
            for (block of qsa(`[data-input-vars]:not([data-problem-id="${problem_id}"])`)) {
                block.style.display = 'none';
            }
            if (qs(`[data-problem-id="${problem_id}"]`)) {
                qs(`[data-problem-id="${problem_id}"]`).style.display = 'grid';
            }
        }

        // Generate start
        qs('#generate_btn').addEventListener('click', function (e) {
            e.preventDefault();
            generate_info.innerText = '';
            generate_btn.disabled = true;
            generate_btn.value = 'Solving...';
            form = document.forms.input;
            let form_data = serializeForm(form);
            form_data.problem = problems[form_data.problem];
            if (qs(`[data-problem-id="${form.problem.value}"]`)) {
                form_data.problem.input_vars = serializeForm(
                    qs(`[data-problem-id="${form.problem.value}"]`)
                );
                for (key in form_data.problem.input_vars) {
                    form_data.problem.input_vars[key] = parseInt(form_data.problem.input_vars[key]);
                }
            }
            setTimeout(() => {
                start_time = new Date();
                printGraph(form_data);
            }, 20);
        });
        let source_base = `
#lineWidth: 1
#spacing: 25
#arrowSize: 0.7
#gutter: 1

#background #eee
#.good: fill=#9f9 bold
#.bad: fill=white dashed
#.important: fill=#99f bold
#.goodtable: fill=#9f9 bold visual=table
#.badtable: fill=white dashed visual=table
#.importanttable: fill=#99f bold visual=table

`;

        function compare(obj1, obj2) {
            if (obj1 === obj2) {
                return true;
            }
            for (let key in obj1) {
                if (obj1[key] !== obj2[key]) {
                    return false;
                }
            }
            return true;
        }

        function newId() {
            return Math.random().toString(32).substr(2);
        }

        function expandTree(state, config, counter = 1) {
            if (!state.valid || compare(state.data, config.problem.finish)) {
                return;
            }
            let children = config.problem.getChildrenData(state);
            
            children = children.map(child => {
                child = {
                    id: newId(),
                    data: child,
                    parent: state,
                    valid: config.problem.check(child),
                    steps: counter,
                };

                return child;
            });

            children = children.filter(child => !parentHasState(child.parent, child));
            
            if (config.mode === 'shortest') {
                // we need to pass the data to the original tree, so we can search in it right after
                state.children = children;

                for (child of state.children) {
                    let best_match = getExistingItemsByData(child.data, tree, child.id)
                        .sort((a,b) => a.steps - b.steps)[0] || null;
                    if (best_match && best_match.steps <= child.steps) {
                        // the tree already contains this position, with a smaller step count, so we can discard this
                        child.valid = false;
                    }
                }

                state.children = state.children.filter(child => child.valid);
            }

            for (child of (config.mode === 'all' ? children : state.children)) {
                if (child.valid) {
                    expandTree(child, config, counter + 1)
                }
            }

            if (config.mode === 'all') {
                state.children = children;
            }
        }

        function treeContains(state, tree) {
            return compare(state.data, tree.data) ||
                (tree.children || []).some(child => treeContains(state, child));
        }

        function getExistingItemsByData(data, tree, exclude_id = null) {
            let results = [];
            if (compare(data, tree.data) && tree.id !== exclude_id) {
                results.push(tree);
            }
            for (child of tree.children || []) {
                child_results = getExistingItemsByData(data, child, exclude_id);
                if (child_results.length) {
                    results.push(...child_results);
                }
            }
            return results;
        }

        function getBestChild(tree, config) {
            return getExistingItemsByData(config.problem.finish, tree)
                .sort((a,b) => a.steps - b.steps)[0] || null;
        }

        function cleanUpTree(ending) {
            if (ending.parent) {
                if (ending.parent.children.length > 1) {
                    ending.parent.children = ending.parent.children.filter(child => child.id === ending.id);
                }
                cleanUpTree(ending.parent);
            }
        }
        
        function parentHasState(prev, state) {
            return compare(prev.data, state.data) || (
                prev.parent && parentHasState(prev.parent, state)
            );
        }

        /* Generate string output based on data */
        function render(state, config) {
            if (config.format === 'pretty' && config.problem.customRender) {
                return config.problem.customRender(state);
            }
            let style = state.valid ? 'good' : 'bad';
            let append = '';
            if (compare(state.data, config.problem.start) || compare(state.data, config.problem.finish)) {
                style = 'important';
                if (state.steps > 0) {
                    append = '|' + state.steps + ' steps';
                }
            }
            modifier = `<${style} id=${state.id}>`;
            // modifier = `<${style}>`;
            return '[' + modifier + Object.values(state.data).toString() + append + ']';
        }

        /* Generate source code for the diagram */
        function printTree(tree, config, prev = null) {
            rows = [];
            if (prev) {
                rows.push(render(prev, config) + '->' + render(tree, config));
            } else {
                rows.push(render(tree, config));
            }
            for (item of tree.children || []) {
                rows = rows.concat(printTree(item, config, tree));
            }
            return rows.join('\n');
        }

        let tree = {
            steps: 0,
        }

        function printGraph(config) {
            tree = {
                id: newId(),
                data: config.problem.start,
                valid: config.problem.check(config.problem.start),
                steps: 0,
            }
            try {
                expandTree(tree, config);

                if (config.mode === 'shortest') {
                    let best_child = getBestChild(tree, config);
                    if (!best_child) {
                        alert('Could not find any solve paths.');
                    } else {
                        cleanUpTree(best_child);
                    }
                }
            } catch (err) {
                alert('An error occured while expanding data tree: ' + err.toString());
                return;
            }
            
            generate_btn.value = 'Rendering...';
            generate_info.innerText = 'Data tree expanded in ' + ((new Date() - start_time)/1000).toFixed(3) + ' seconds.';
            
            setTimeout(() => {
                start_time = new Date();
                try {
                    let graph = printTree(tree, config);
            
                    // let source = source_base + `[<container>${config.problem.title}|\n${graph}\n]`;
                    
                    let extra_options = `
    #direction: ${config.direction}
                    `;
                    let source = extra_options + source_base + graph;
            
                    
                    if (config.output === 'png') {
                        qs('#canvas_output').style.display = 'block';
                        nomnoml.draw(qs('#canvas_output'), source);
                        qs('#svg_output').innerHTML = '';
                        qs('#svg_output').style.display = 'none';
                    } else {
                        qs('#canvas_output').style.display = 'none';
                        svg = nomnoml.renderSvg(source);
                        qs('#svg_output').innerHTML = svg;
                        qs('#svg_output').style.display = 'inline-block';
                    }
    
                } catch (err) {
                    alert('An error occured: graph is too big to render.\nTry generating the shortest path only.');
                    throw err;
                    return;
                }
                generate_info.innerText += ' Rendered in ' + ((new Date() - start_time)/1000).toFixed(3) + ' seconds.';
                generate_btn.value = 'Generate';
                generate_btn.disabled = false;
            }, 20);

        }
    </script>
</body>
</html>