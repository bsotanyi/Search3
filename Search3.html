<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Search3</title>
    <style>
        *, *::after, *::before {
            box-sizing: border-box;
        }
        body {
            font-family: Tahoma, sans-serif;
        }
        h1 {
            margin: 0;
            text-align: center;
            letter-spacing: 2px;
        }
        h1 mark {
            background: inherit;
            color: #299;
        }
        .grid-2 {
            display: grid;
            grid: auto / 1fr 1fr;
        }
        .form-group:not(:last-of-type) {
            margin-bottom: 1em;
        }
        .form-group > * {
            display: block;
        }
        select, input {
            font-size: 1em;
        }
        fieldset {
            margin: 0;
            border: 1px solid #666;
            border-radius: .3rem;
        }
        canvas {
            background-color: #eee;
            border: 1px solid #666;
            margin-top: 8px;
            display: none;
            border-radius: .3rem;
        }
        #input_area fieldset {
            gap: 2px;
        }
        .js-num {
            display: grid;
            grid: auto / 2em 1fr 2em;
            gap: 2px;
        }
    </style>
</head>
<body>
    <h1>Search<mark>3</mark></h1>
    <fieldset class="grid-2">
        <legend>Options</legend>
        <form id="input">
            <div class="grid-2">
                <div class="form-group">
                    <div>
                        <label>Problem:</label>
                        <select name="problem" id="problem"></select>
                    </div>
                </div>
                <div class="form-group">
                    <label>Graph format:</label>
                    <label>
                        <input type="radio" name="format" value="compact"></input>
                        compact (small, faster)
                    </label>
                    <label><input type="radio" name="format" value="pretty" checked></input>
                        pretty (large, slower)
                    </label>
                </div>
                <div class="grid-2">
                    <div class="form-group">
                        <label>Graph direction:</label>
                        <label>
                            <input type="radio" name="direction" value="down" checked></input>
                            down ↓
                        </label>
                        <label><input type="radio" name="direction" value="right"></input>
                            right →
                        </label>
                    </div>
                    <div class="form-group">
                        <label>Output type:</label>
                        <label>
                            <input type="radio" name="output" value="png" checked></input>
                            canvas (PNG)
                        </label>
                        <label><input type="radio" name="output" value="svg"></input>
                            SVG
                        </label>
                    </div>
                </div>
                <div class="form-group">
                    <label>I want to see:</label>
                    <label>
                        <input type="radio" name="mode" value="all" checked></input>
                        all possible paths
                    </label>
                    <label><input type="radio" name="mode" value="shortest"></input>
                        only the shortest possible path
                    </label>
                </div>
            </div>
            <br>
            <input type="submit" value="Generate" id="generate_btn">
            <span id="generate_info"></span>
        </form>
        <div id="input_area"></div>
    </fieldset>

    <canvas id="canvas_output"></canvas>
    <div id="svg_output"></div>
    <script src="graphre.js"></script>
    <script src="nomnoml.js"></script>
    <script>
        let problems = [];
    </script>
    <script src="problems/wolf-goat-cabbage.js"></script>
    <script src="problems/cannibals-priests.js"></script>
    <script src="problems/jumping-frogs.js"></script>
    <script>
        function qs(selector, parent_el = document) { return parent_el.querySelector(selector); }
        function qsa(selector, parent_el = document) { return [...parent_el.querySelectorAll(selector)]; }
        function serializeForm(form) {
            var obj = {};
            var formData = new FormData(form);
            for (var key of formData.keys()) {
                obj[key] = formData.get(key);
            }
            return obj;
        };

        let input_html = '';
        for (let i in problems) {
            let new_opt = new Option(problems[i].title, i);
            qs('#problem').add(new_opt, undefined);

            if (problems[i].input_vars) {
                let inputs = ``;
                for (key in problems[i].input_vars) {
                    inputs += `
                        <label>${key}</label>
                        <div class="js-num">
                            <button type="button" class="js-minus">-</button>
                            <input name="${key}" type="number" value="${problems[i].input_vars[key]}">
                            <button type="button" class="js-plus">+</button>
                        </div>
                    `;
                }
                input_html += `<form style="display:none" data-input-vars data-problem-id="${i}">
                    <fieldset class="grid-2">
                        <legend>Input variables</legend>
                        ${inputs}
                    </fieldset>
                </form>`;
            }
        }
        qs('#input_area').innerHTML = input_html;
        for (let num of qsa('.js-num')) {
            qs('.js-plus', num).onclick = () => qs('input', num).value = ~~qs('input', num).value + 1;
            qs('.js-minus', num).onclick = () => qs('input', num).value = ~~qs('input', num).value - 1;
        }
        
        qs('#problem').addEventListener('input', function() {
            refreshInputArea(this.value);
        });
        refreshInputArea(qs('#problem').value);

        function refreshInputArea(problem_id) {
            for (block of qsa(`[data-input-vars]:not([data-problem-id="${problem_id}"])`)) {
                block.style.display = 'none';
            }
            if (qs(`[data-problem-id="${problem_id}"]`)) {
                qs(`[data-problem-id="${problem_id}"]`).style.display = 'grid';
            }
        }

        // Generate start
        qs('#input').addEventListener('submit', function (e) {
            e.preventDefault();
            generate_info.innerText = '';
            generate_btn.disabled = true;
            generate_btn.value = 'Generating...';
            let form_data = serializeForm(this);
            form_data.problem = problems[form_data.problem];
            if (qs(`[data-problem-id="${this.problem.value}"]`)) {
                form_data.problem.input_vars = serializeForm(
                    qs(`[data-problem-id="${this.problem.value}"]`)
                );
                for (key in form_data.problem.input_vars) {
                    form_data.problem.input_vars[key] = parseInt(form_data.problem.input_vars[key]);
                }
            }
            setTimeout(() => {
                let start_time = new Date();
                printGraph(form_data);
                generate_btn.disabled = false;
                generate_btn.value = 'Generate';
                generate_info.innerText = 'Generated in ' + ((new Date() - start_time)/1000).toFixed(3) + ' seconds.';
            }, 10);
        });
        let source_base = `
#lineWidth: 1
#spacing: 25
#arrowSize: 0.7
#gutter: 1

#.container fill=
#.good: fill=#9f9 bold
#.bad: fill=white dashed
#.important: fill=#99f bold
#.goodtable: fill=#9f9 bold visual=table
#.badtable: fill=white dashed visual=table
#.importanttable: fill=#99f bold visual=table

`;

        function compare(obj1, obj2) {
            if (obj1 === obj2) {
                return true;
            }
            for (let key in obj1) {
                if (obj1[key] !== obj2[key]) {
                    return false;
                }
            }
            return true;
        }

        function newId() {
            return Math.random().toString(32).substr(2);
        }

        function expandTree(state, config, counter = 1) {
            if (!state.valid || compare(state.data, config.problem.finish)) {
                return;
            }
            let children = config.problem.getChildrenData(state);
            
            children = children.map(child => {
                child = {
                    id: newId(),
                    data: child,
                    parent: state,
                    valid: config.problem.check(child),
                    steps: counter,
                };

                return child;
            });

            children = children.filter(child => !parentHasState(child.parent, child));

            for (child of children) {
                if (child.valid && !parentHasState(state, child)) {
                    expandTree(child, config, counter + 1)
                }
            }

            state.children = children;
        }
        
        function parentHasState(prev, state) {
            return (compare(prev.data, state.data)) || (
                prev.parent && parentHasState(prev.parent, state)
            );
        }

        /* Generate string output based on data */
        function echo(state, config) {
            if (config.format === 'pretty' && config.problem.customEcho) {
                return config.problem.customEcho(state);
            }
            let style = state.valid ? 'good' : 'bad';
            let append = '';
            if (compare(state.data, config.problem.start) || compare(state.data, config.problem.finish)) {
                style = 'important';
                if (state.steps > 0) {
                    append = '|' + state.steps + ' steps';
                }
            }
            modifier = `<${style} id=${state.id}>`;
            // modifier = `<${style}>`;
            return '[' + modifier + Object.values(state.data).toString() + append + ']';
        }

        /* Generate source code for the diagram */
        function printTree(tree, config, prev = null) {
            rows = [];
            if (prev) {
                rows.push(echo(prev, config) + '->' + echo(tree, config));
            } else {
                rows.push(echo(tree, config));
            }
            for (item of tree.children || []) {
                rows = rows.concat(printTree(item, config, tree));
            }
            return rows.join('\n');
        }

        function printGraph(config) {
            var tree = {
                id: newId(),
                data: config.problem.start,
                valid: config.problem.check(config.problem.start),
                steps: 0,
            }
            try {
                expandTree(tree, config);
            } catch (err) {
                alert('An error occured while expanding data tree: ' + err.toString());
                return;
            }

            try {
                let graph = printTree(tree, config);
        
                // let source = source_base + `[<container>${config.problem.title}|\n${graph}\n]`;
                
                let plus_options = `
#direction: ${qs('[name="direction"]:checked').value}
                `;
                let source = plus_options + source_base + graph;
        
                
                if (qs('[name="output"]:checked').value === 'png') {
                    qs('#canvas_output').style.display = 'block';
                    nomnoml.draw(qs('#canvas_output'), source);
                    qs('#svg_output').innerHTML = '';
                } else {
                    qs('#canvas_output').style.display = 'none';
                    svg = nomnoml.renderSvg(source);
                    qs('#svg_output').innerHTML = svg;
                }

            } catch (err) {
                alert('An error occured: graph is too big to render.');
                return;
            }
        }
    </script>
</body>
</html>